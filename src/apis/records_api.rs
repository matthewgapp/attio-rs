/*
 * Attio API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@attio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`v2_objects_object_records_post`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsPostParams {
    pub object: String,
    pub v2_objects_object_records_post_request: crate::models::V2ObjectsObjectRecordsPostRequest
}

/// struct for passing parameters to the method [`v2_objects_object_records_put`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsPutParams {
    pub object: String,
    pub matching_attribute: String,
    pub v2_objects_object_records_put_request: crate::models::V2ObjectsObjectRecordsPutRequest
}

/// struct for passing parameters to the method [`v2_objects_object_records_query_post`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsQueryPostParams {
    pub object: String,
    pub v2_objects_object_records_query_post_request: crate::models::V2ObjectsObjectRecordsQueryPostRequest
}

/// struct for passing parameters to the method [`v2_objects_object_records_record_id_attributes_attribute_values_get`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetParams {
    pub object: String,
    pub record_id: String,
    pub attribute: String,
    pub show_historic: Option<bool>,
    pub limit: Option<i32>,
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v2_objects_object_records_record_id_delete`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsRecordIdDeleteParams {
    pub object: String,
    pub record_id: String
}

/// struct for passing parameters to the method [`v2_objects_object_records_record_id_entries_get`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsRecordIdEntriesGetParams {
    pub object: String,
    pub record_id: String,
    pub limit: Option<i32>,
    pub offset: Option<i32>
}

/// struct for passing parameters to the method [`v2_objects_object_records_record_id_get`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsRecordIdGetParams {
    pub object: String,
    pub record_id: String
}

/// struct for passing parameters to the method [`v2_objects_object_records_record_id_patch`]
#[derive(Clone, Debug)]
pub struct V2ObjectsObjectRecordsRecordIdPatchParams {
    pub object: String,
    pub record_id: String,
    pub v2_objects_object_records_put_request: crate::models::V2ObjectsObjectRecordsPutRequest
}


/// struct for typed errors of method [`v2_objects_object_records_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsPostError {
    Status400(crate::models::V2ObjectsObjectRecordsPost400Response),
    Status404(crate::models::V2ObjectsObjectGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsPutError {
    Status400(crate::models::V2ObjectsObjectRecordsPut400Response),
    Status404(crate::models::V2ObjectsObjectGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_query_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsQueryPostError {
    Status400(crate::models::V2ObjectsObjectRecordsQueryPost400Response),
    Status404(crate::models::V2ObjectsObjectRecordsQueryPost404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_record_id_attributes_attribute_values_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetError {
    Status400(crate::models::V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet400Response),
    Status404(crate::models::V2TargetIdentifierAttributesAttributeGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_record_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsRecordIdDeleteError {
    Status404(crate::models::V2ObjectsObjectRecordsRecordIdGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_record_id_entries_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsRecordIdEntriesGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_record_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsRecordIdGetError {
    Status404(crate::models::V2ObjectsObjectRecordsRecordIdGet404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_objects_object_records_record_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2ObjectsObjectRecordsRecordIdPatchError {
    Status400(crate::models::V2ObjectsObjectRecordsRecordIdPatch400Response),
    Status404(crate::models::V2ObjectsObjectGet404Response),
    UnknownValue(serde_json::Value),
}


/// Creates a new person, company or other record. This endpoint will throw on conflicts of unique attributes. If you would prefer to update records on conflicts, please use the [Assert record endpoint](/reference/put_v2-objects-object-records) instead.  Required scopes: `record_permission:read-write`, `object_configuration:read`.
pub async fn v2_objects_object_records_post(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsPostParams) -> Result<crate::models::V2ObjectsObjectRecordsPut200Response, Error<V2ObjectsObjectRecordsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let v2_objects_object_records_post_request = params.v2_objects_object_records_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records", local_var_configuration.base_path, object=crate::apis::urlencode(object));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&v2_objects_object_records_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use this endpoint to create or update people, companies and other records. A matching attribute is used to search for existing records. If a record is found with the same value for the matching attribute, that record will be updated. If no record with the same value for the matching attribute is found, a new record will be created instead. If you would like to avoid matching, please use the [Create record endpoint](/reference/post_v2-objects-object-records).  If the matching attribute is a multiselect attribute, new values will be added and existing values will not be deleted. For any other multiselect attribute, all values will be either created or deleted as necessary to match the list of supplied values.  Required scopes: `record_permission:read-write`, `object_configuration:read`.
pub async fn v2_objects_object_records_put(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsPutParams) -> Result<crate::models::V2ObjectsObjectRecordsPut200Response, Error<V2ObjectsObjectRecordsPutError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let matching_attribute = params.matching_attribute;
    let v2_objects_object_records_put_request = params.v2_objects_object_records_put_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records", local_var_configuration.base_path, object=crate::apis::urlencode(object));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("matching_attribute", &matching_attribute.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&v2_objects_object_records_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsPutError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists people, company or other records, with the option to filter and sort results.  Required scopes: `record_permission:read`, `object_configuration:read`.
pub async fn v2_objects_object_records_query_post(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsQueryPostParams) -> Result<crate::models::V2ObjectsObjectRecordsQueryPost200Response, Error<V2ObjectsObjectRecordsQueryPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let v2_objects_object_records_query_post_request = params.v2_objects_object_records_query_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/query", local_var_configuration.base_path, object=crate::apis::urlencode(object));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&v2_objects_object_records_query_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsQueryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets all values for a given attribute on a record. If the attribute is historic, this endpoint has the ability to return all historic values using the `show_historic` query param.  Required scopes: `record_permission:read`, `object_configuration:read`.
pub async fn v2_objects_object_records_record_id_attributes_attribute_values_get(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetParams) -> Result<crate::models::V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGet200Response, Error<V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let record_id = params.record_id;
    let attribute = params.attribute;
    let show_historic = params.show_historic;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/{record_id}/attributes/{attribute}/values", local_var_configuration.base_path, object=crate::apis::urlencode(object), record_id=crate::apis::urlencode(record_id), attribute=crate::apis::urlencode(attribute));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = show_historic {
        local_var_req_builder = local_var_req_builder.query(&[("show_historic", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsRecordIdAttributesAttributeValuesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes a single record (e.g. a company or person) by ID.  Required scopes: `object_configuration:read`, `record_permission:read-write`.
pub async fn v2_objects_object_records_record_id_delete(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsRecordIdDeleteParams) -> Result<serde_json::Value, Error<V2ObjectsObjectRecordsRecordIdDeleteError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let record_id = params.record_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/{record_id}", local_var_configuration.base_path, object=crate::apis::urlencode(object), record_id=crate::apis::urlencode(record_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsRecordIdDeleteError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// List all entries, across all lists, for which this record is the parent.  Required scopes: `record_permission:read`, `object_configuration:read`, `list_entry:read`.
pub async fn v2_objects_object_records_record_id_entries_get(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsRecordIdEntriesGetParams) -> Result<crate::models::V2ObjectsObjectRecordsRecordIdEntriesGet200Response, Error<V2ObjectsObjectRecordsRecordIdEntriesGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let record_id = params.record_id;
    let limit = params.limit;
    let offset = params.offset;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/{record_id}/entries", local_var_configuration.base_path, object=crate::apis::urlencode(object), record_id=crate::apis::urlencode(record_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsRecordIdEntriesGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Gets a single person, company or other record by its `record_id`.  Required scopes: `record_permission:read`, `object_configuration:read`.
pub async fn v2_objects_object_records_record_id_get(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsRecordIdGetParams) -> Result<crate::models::V2ObjectsObjectRecordsPut200Response, Error<V2ObjectsObjectRecordsRecordIdGetError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let record_id = params.record_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/{record_id}", local_var_configuration.base_path, object=crate::apis::urlencode(object), record_id=crate::apis::urlencode(record_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsRecordIdGetError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Use this endpoint to update people, companies and other records by `record_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the [Assert record endpoint](/reference/put_v2-objects-object-records) to overwrite or remove multiselect attribute values.  Required scopes: `record_permission:read-write`, `object_configuration:read`.
pub async fn v2_objects_object_records_record_id_patch(configuration: &configuration::Configuration, params: V2ObjectsObjectRecordsRecordIdPatchParams) -> Result<crate::models::V2ObjectsObjectRecordsPut200Response, Error<V2ObjectsObjectRecordsRecordIdPatchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let object = params.object;
    let record_id = params.record_id;
    let v2_objects_object_records_put_request = params.v2_objects_object_records_put_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/objects/{object}/records/{record_id}", local_var_configuration.base_path, object=crate::apis::urlencode(object), record_id=crate::apis::urlencode(record_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.oauth_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&v2_objects_object_records_put_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2ObjectsObjectRecordsRecordIdPatchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

